% REDUCENOISE   perform noise correction algorithm on gain and offset corrected sCMOS images
% 
% SYNOPSIS:
%   Default:
%       [outL] = reducenoise(Rs,imsd,varmap,gainmap,imgsz,Pixelsize,NA,Lambda,alpha,iterationN)
%   Noise only:  
%       [out] = reducenoise(Rs,imsd,varsub,gainsub,imgsz,Pixelsize,NA,Lambda,alpha,iterationN,'pureN');
%   Adjustable:
%       [out] = reducenoise(Rs,imsd,varsub,gainsub,imgsz,Pixelsize,NA,Lambda,alpha,iterationN,'adjustable',w,h);
%       w is the radius of the OTF mask, unit in NA/Lambda, h is the height
%       of the OTF radius.
%   User defined:
%       [out] = reducenoise(Rs,imsd,varsub,gainsub,imgsz,Pixelsize,NA,Lambda,alpha,iterationN,otfmask);
%       otfmask is a 2D maxtrix generated by the user, and the size of otfmask must
%       be equal to Rs+2 x Rs+2.
%
% INPUTS:
%   Rs
%       Size of segmented images
%   imsd
%       Image(s) from sCMOS camera after gain and offset correction
%   varmap
%       selected variance map, it should be either a 2D matrix, with a size
%       the same as the first two dimention of imsd, or a 3D matrix, with
%       the same size as imsd
%   gainmap
%       selected gain map, size should be the same as varmap
%   Pixelsize
%       The pixel size on the sample plane, unit is micron
%   NA
%       Numerical aperture of the objective lens
%   Lambda
%       Emission wavelength of the sample, unit is micron
%   alpha
%       weight factor of noise contribution only
%   iterationN
%       Iteration number of fminunc optimization process
%   
% OUTPUTS:
%   outL
%       Noise corrected image(s)
%
% (C) Copyright 2017                The Huang Lab
%     All rights reserved           Weldon School of Biomedical Engineering
%                                   Purdue University
%                                   West Lafayette, Indiana
%                                   USA
% Sheng Liu, June 2017

function [outL] = reducenoise(Rs,imsd,varmap,gainmap,imgsz,Pixelsize,NA,Lambda,alpha,iterationN,otfmask,w,h)
otfsize = 2;                    % OTF size is twice of the pupil size
qsz = (Rs+2);                   % size of OTF mask image
% selection and generation of the OTF mask
switch nargin
    case 10
        [rcfilter] = genfilter(qsz,Pixelsize,otfsize*NA,Lambda);
    case 11
        if isnumeric(otfmask)
            if size(otfmask)~=qsz
                error('NCS:incorrectsize','The OTF mask size must be Rs+2 x Rs+2.')
            end
                rcfilter = otfmask;
        else
            [rcfilter] = genfilter(qsz,Pixelsize,otfsize*NA,Lambda,otfmask);
        end
    case 13
        [rcfilter] = genfilter(qsz,Pixelsize,NA,Lambda,otfmask,w,h);
end
% image segmentation, each segment has a size of Rs by Rs pixels
if ndims(gainmap) == 2
    [varseg] = segpadimg(varmap,Rs);
    [gainseg] = segpadimg(gainmap,Rs);
end
N = size(imsd,3);
outL = zeros(size(imsd));       % noise corrected image stack
if ndims(gainmap) == 3
    if size(gainmap,3) ~= size(imsd,3)
        error('NCS:incorrectsize','The size of the gain stack must be equal to the size of the input image.')
    end
    if size(varmap,3) ~= size(imsd,3)
        error('NCS:incorrectsize','The size of the variance stack must be equal to the size of the input image.')
    end
    parfor ii = 1:N
        disp(ii)
        [varseg] = segpadimg(varmap(:,:,ii),Rs);
        [gainseg] = segpadimg(gainmap(:,:,ii),Rs);
        [out] = optimf(imsd(:,:,ii),varseg,gainseg,rcfilter,Rs,imgsz,alpha,iterationN);
        outL(:,:,ii) = out;
    end
else
    for ii = 1:N
        disp(ii)
        [out] = optimf(imsd(:,:,ii),varseg,gainseg,rcfilter,Rs,imgsz,alpha,iterationN);
        outL(:,:,ii) = out;
    end
end

end

function [out] = optimf(u0,varseg,gainseg,invpupil,Rs,imgsz,alpha,iterationN)
Ns = imgsz/Rs;                  % number of segments
% image segmentation, each segment has a size of Rs by Rs pixels
[u0seg] = segpadimg(u0,Rs);
opts = optimoptions('fminunc','MaxIter',iterationN,'algorithm','quasi-newton');
useg = zeros(size(u0seg));      % to store noise corrected segments 
% begin noise correction algorithm on each segments using parallel toolbox
% to process all segments at the same time
tic
parfor ii = 1:Ns*Ns
    u0i = u0seg(:,:,ii);
    vari = varseg(:,:,ii);
    gaini = gainseg(:,:,ii);
    outi = fminunc(@(x)calcost(x,u0i,vari,gaini,invpupil,alpha), u0i,opts);
    useg(:,:,ii) = outi;
end
toc
% stitch segments together
[out] = stitchpadimg(useg);
out(out<0) = 1e-6;              % output noise corrected image

end
